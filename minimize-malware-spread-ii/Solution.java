import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Set;

public class Solution {
	public int minMalwareSpread(int[][] graph, int[] initial) {
		int nodeNum = graph.length;

		boolean[] initials = new boolean[nodeNum];
		for (int node : initial) {
			initials[node] = true;
		}

		@SuppressWarnings("unchecked")
		Set<Integer>[] sourceSets = new Set[nodeNum];
		for (int node = 0; node < nodeNum; node++) {
			sourceSets[node] = new HashSet<>();
		}

		Queue<Element> queue = new LinkedList<>();
		for (int node : initial) {
			queue.offer(new Element(node, node));
		}

		while (!queue.isEmpty()) {
			Element head = queue.poll();

			for (int adjNode = 0; adjNode < nodeNum; adjNode++) {
				if (graph[head.node][adjNode] == 1 && !initials[adjNode]
						&& !sourceSets[adjNode].contains(head.source)) {
					sourceSets[adjNode].add(head.source);

					queue.offer(new Element(adjNode, head.source));
				}
			}
		}

		int[] singleSourceToCount = new int[nodeNum];
		for (Set<Integer> sourceSet : sourceSets) {
			if (sourceSet.size() == 1) {
				singleSourceToCount[sourceSet.iterator().next()]++;
			}
		}

		int maxCountForSingleSource = Arrays.stream(singleSourceToCount).max().getAsInt();
		if (maxCountForSingleSource == 0) {
			return Arrays.stream(initial).min().getAsInt();
		} else {
			for (int i = 0;; i++) {
				if (singleSourceToCount[i] == maxCountForSingleSource) {
					return i;
				}
			}
		}
	}
}

class Element {
	int node;
	int source;

	Element(int node, int source) {
		this.node = node;
		this.source = source;
	}
}